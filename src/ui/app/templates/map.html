<!doctype html>
<meta charset="utf-8">
<title>Top-Down Map (135×135)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0d12;color:#e8edf4;font:14px system-ui}
  .wrap{max-width:820px;margin:16px auto;padding:12px}
  canvas{width:100%;height:auto;display:block;border:1px solid #223045;border-radius:10px;background:#0e1420}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between}
</style>
<div class="wrap">
  <div class="row">
    <div>World: 135×135 (0,0 center)</div>
    <div id="info">—</div>
  </div>
  <canvas id="cv" width="800" height="800"></canvas>
</div>
<script>
const WORLD_SIZE = 135;              // units
const HALF = WORLD_SIZE/2;
const BG_IMAGE_URL = "/resources/EnvTopView.png"; // <-- set to your image path

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const info = document.getElementById('info');

const img = new Image(); img.src = BG_IMAGE_URL; img.onload = draw;
let last = {name:'—', state:'—', battery:0, pos:{x:0,y:0}, tgt:{x:0,y:0}};

function worldToScreen(x, y){
  // +x right, +y up; canvas origin top-left
  const s = cv.width / WORLD_SIZE;          // pixels per unit (square canvas)
  const cx = cv.width/2, cy = cv.height/2;  // center in pixels
  return { x: cx + x*s, y: cy - y*s };
}

function drawGrid(){
  const s = cv.width / WORLD_SIZE;
  ctx.lineWidth = 1;
  for (let u = Math.ceil(-HALF); u <= Math.floor(HALF); u++){
    // verticals (x = u)
    const vx = worldToScreen(u,0).x;
    ctx.strokeStyle = (u===0) ? '#52a2ff55' : (u%10===0 ? '#ffffff22' : u%5===0 ? '#ffffff17' : '#ffffff10');
    ctx.beginPath(); ctx.moveTo(vx, 0); ctx.lineTo(vx, cv.height); ctx.stroke();
    // horizontals (y = u)
    const hy = worldToScreen(0,u).y;
    ctx.strokeStyle = (u===0) ? '#52a2ff55' : (u%10===0 ? '#ffffff22' : u%5===0 ? '#ffffff17' : '#ffffff10');
    ctx.beginPath(); ctx.moveTo(0, hy); ctx.lineTo(cv.width, hy); ctx.stroke();
  }
}

function drawBackground(){
  // cover the square canvas while preserving aspect
  const iw = img.width, ih = img.height;
  const cw = cv.width, ch = cv.height;
  const r = Math.max(cw/iw, ch/ih);
  const dw = iw*r, dh = ih*r;
  const dx = (cw - dw)/2, dy = (ch - dh)/2;
  ctx.drawImage(img, dx, dy, dw, dh);
}

function drawDot(x, y, color, r=6){
  const p = worldToScreen(x,y);
  ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2);
  ctx.fillStyle = color; ctx.fill();
  ctx.lineWidth = 2; ctx.strokeStyle = '#00000066'; ctx.stroke();
}

function draw(){
  // base
  ctx.clearRect(0,0,cv.width,cv.height);
  if (img.complete) drawBackground();
  drawGrid();

  // target first, then robot on top
  drawDot(last.tgt.x, last.tgt.y, '#ffd34d', 5);   // target: yellow
  drawDot(last.pos.x, last.pos.y, '#4aa3ff', 6);   // robot: blue

  // legend
  ctx.fillStyle = '#e8edf4'; ctx.font = '13px system-ui';
  ctx.fillText(`Robot: ${last.name} · State: ${last.state} · Battery: ${last.battery}%`, 12, 20);
}

async function fetchStatus(){
  try{
    const r = await fetch('/api/status', {cache:'no-store'});
    const j = await r.json();
    last = {
      name: j.name ?? '—',
      state: j.current_state ?? '—',
      battery: Number(j.battery ?? 0),
      pos: {x:Number(j.current_position?.x ?? 0), y:Number(j.current_position?.y ?? 0)},
      tgt: {x:Number(j.target_position?.x ?? 0),  y:Number(j.target_position?.y ?? 0)},
    };
    info.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
  }catch(e){
    info.textContent = 'Update failed';
  }finally{
    draw();
  }
}

function resize(){
  // keep canvas square, fit container width
  const w = cv.clientWidth;
  cv.width = w; cv.height = w;
  draw();
}

window.addEventListener('resize', resize);
resize();
fetchStatus();
setInterval(fetchStatus, 1000);
</script>
