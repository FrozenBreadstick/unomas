<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>UNO MAS · Soil Heatmap</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{
    --bg:#0b0d12; --panel:#121622; --muted:#9aa3b2; --text:#e8edf4;
    --accent:#4aa3ff; --ok:#22c55e; --warn:#f59e0b; --err:#ef4444; --card:#151a28;
    --border:#202636;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:radial-gradient(1200px 800px at 20% -10%, #0f1422 0, #0b0d12 60%),
              linear-gradient(180deg,#0b0d12,#0b0d12);
    color:var(--text);
    font:16px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;
    display:flex;
    flex-direction:column;
  }
  header{padding:20px 24px;border-bottom:1px solid var(--border);background:#0c111b88;backdrop-filter:blur(6px)}
  header h1{margin:0;font-size:18px;font-weight:600;letter-spacing:.2px}
  main{max-width:1080px;width:100%;margin:28px auto;padding:0 16px;flex:1}
  .grid{display:grid;gap:16px;grid-template-columns:1.1fr .9fr}
  @media(max-width:980px){.grid{grid-template-columns:1fr}}
  .card{
    background:linear-gradient(180deg,#151b2a,#121826);
    border:1px solid var(--border);
    border-radius:14px;
    padding:18px;
    box-shadow:0 10px 30px rgba(0,0,0,.25);
  }
  .header-row{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .name{font-size:22px;font-weight:700;letter-spacing:.3px}
  .muted{color:var(--muted)}
  .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#0e1422;font-size:13px}
  .dot{width:8px;height:8px;border-radius:50%}
  .dot.idle{background:var(--muted)}
  .dot.active{background:var(--ok)}
  .dot.err{background:var(--err)}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:#101728;font-size:13px}
  .right{margin-left:auto}
  .section-title{font-size:14px;color:var(--muted);margin:14px 0 8px}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media(max-width:520px){.kpi{grid-template-columns:1fr 1fr}}
  .kpi .tile{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px}
  .kpi .label{color:var(--muted);font-size:12px;letter-spacing:.2px}
  .kpi .value{font-size:18px;margin-top:4px;font-weight:600}
  .progress-wrap{display:flex;align-items:center;gap:12px}
  .progress{flex:1;height:10px;background:#0e1420;border:1px solid var(--border);border-radius:999px;overflow:hidden}
  .progress>span{display:block;height:100%;background:linear-gradient(90deg,#4aa3ff,#22c55e)}
  #controls{display:grid;gap:12px;padding:14px;border:1px solid var(--border);border-radius:12px;background:#101728;font-size:13px;margin-top:16px}
  #controls label{display:flex;flex-direction:column;gap:6px;font-size:13px}
  #controls input[type="text"],
  #controls input[type="range"]{
    background:#0e1420;
    border:1px solid var(--border);
    border-radius:8px;
    padding:6px 8px;
    color:var(--text);
    font-size:13px;
  }
  #controls input[type="checkbox"]{transform:scale(1.1)}
  #controls button{
    background:#172033;
    border:1px solid var(--border);
    border-radius:8px;
    color:var(--text);
    padding:6px 10px;
    font-size:13px;
    cursor:pointer;
    transition:background .15s ease,border-color .15s ease;
  }
  #controls button:hover{background:#1f2a3d;border-color:#2a354f}
  #controls button:disabled{opacity:.4;cursor:not-allowed}
  .primary-button{background:var(--accent);border-color:#2c7bd4;color:#031424;font-weight:600;text-transform:uppercase;letter-spacing:.4px}
  .primary-button:hover{background:#5bb1ff}
  .mode-button.active{background:#203252;border-color:var(--accent)}
  .button-row{display:flex;flex-wrap:wrap;gap:8px}
  .list-box{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:6px;font-size:12px;color:var(--muted);max-height:160px;overflow:auto}
  .list-box li{display:flex;align-items:center;gap:8px}
  .list-box li span{color:var(--text)}
  .list-box li input[type="text"]{flex:1}
  #plan-status{min-height:18px;font-size:12px;color:var(--muted)}
  #plan-status.error{color:var(--err)}
  #plan-status.success{color:var(--ok)}

  #map-area{position:relative;min-height:560px;padding:0}
  #map-wrapper{position:relative;width:100%;aspect-ratio:1/1;border-radius:14px;overflow:hidden;border:1px solid var(--border);background:#0e1420}
  #map-wrapper canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
  #baseCanvas{z-index:1}
  #overlayCanvas{z-index:2;pointer-events:none}
  #routeCanvas{z-index:3;pointer-events:auto}
  #legend{position:absolute;left:16px;bottom:16px;background:#0c111bcc;border:1px solid var(--border);border-radius:10px;padding:8px 10px;font-size:12px;color:var(--muted);z-index:4}
</style>
</head>
<body>
<header>
  <h1>UNO MAS · Robot Dashboard</h1>
</header>

<main>
  <div class="grid">
    <section class="card">
      <div class="header-row">
        <div class="name" id="name">—</div>
        <span class="badge" id="state-badge"><span class="dot idle"></span><strong id="state">—</strong></span>
        <span class="pill" id="emergency-pill"><span class="muted">Emergency</span>: <span id="emergency">—</span></span>
        <span class="pill right muted" id="updated-pill"><span class="muted">Updated</span>: <span id="updated">—</span></span>
      </div>

      <div class="section-title">Battery</div>
      <div class="progress-wrap">
        <div class="progress" aria-label="Battery">
          <span id="battery-bar" style="width:0%"></span>
        </div>
        <strong id="battery-text">0%</strong>
      </div>

      <div class="section-title">Positions</div>
      <div class="kpi">
        <div class="tile"><div class="label">Current X</div><div class="value" id="cur-x">—</div></div>
        <div class="tile"><div class="label">Current Y</div><div class="value" id="cur-y">—</div></div>
        <div class="tile"><div class="label">Current Z</div><div class="value" id="cur-z">—</div></div>
        <div class="tile"><div class="label">Target X</div><div class="value" id="tgt-x">—</div></div>
        <div class="tile"><div class="label">Target Y</div><div class="value" id="tgt-y">—</div></div>
        <div class="tile"><div class="label">Target Z</div><div class="value" id="tgt-z">—</div></div>
      </div>

      <div class="section-title">Controls</div>
      <div id="controls">
        <div class="toggle-row">
          <label><input id="chk-moist" type="checkbox" checked> Moisture</label>
          <label><input id="chk-ph" type="checkbox"> pH</label>
          <label><input id="chk-nutr" type="checkbox"> Nutrients</label>
        </div>
        <div class="slider-row">
          <label>Smooth<br><input id="radius" type="range" min="8" max="45" value="22"></label>
          <label>Resolution<br><input id="res" type="range" min="80" max="300" value="180"></label>
          <label>Opacity<br><input id="alpha" type="range" min="20" max="100" value="65"></label>
        </div>
        <div class="section-title">Route Planning</div>
        <label>Station Namespace<input id="station-name-input" type="text" placeholder="e.g. base_station"></label>
        <label>Robot Address<input id="robot-address-input" type="text" placeholder="robot serial / address"></label>
        <label>Route Width (m)<br><input id="route-width" type="range" min="1" max="8" value="2"></label>
        <div class="button-row">
          <button id="btn-toggle-route" class="mode-button">Start Route</button>
          <button id="btn-complete-route">Complete Route</button>
          <button id="btn-undo-point">Undo Point</button>
          <button id="btn-clear-route">Clear Active</button>
        </div>
        <div>
          <strong class="muted" style="display:block;text-transform:uppercase;font-size:11px;letter-spacing:.4px">Active Route Points</strong>
          <ul id="active-route-list" class="list-box">
            <li>—</li>
          </ul>
        </div>
        <div>
          <strong class="muted" style="display:block;text-transform:uppercase;font-size:11px;letter-spacing:.4px">Saved Routes</strong>
          <ul id="routes-list" class="list-box">
            <li>—</li>
          </ul>
        </div>
        <div class="section-title">Fields</div>
        <div class="button-row">
          <button id="btn-toggle-field" class="mode-button">Start Field</button>
          <button id="btn-complete-field">Complete Field</button>
          <button id="btn-undo-field">Undo Point</button>
          <button id="btn-clear-field">Clear Active</button>
        </div>
        <div>
          <strong class="muted" style="display:block;text-transform:uppercase;font-size:11px;letter-spacing:.4px">Active Field Points</strong>
          <ul id="active-field-list" class="list-box">
            <li>—</li>
          </ul>
        </div>
        <div>
          <strong class="muted" style="display:block;text-transform:uppercase;font-size:11px;letter-spacing:.4px">Fields</strong>
          <ul id="fields-list" class="list-box">
            <li>—</li>
          </ul>
        </div>
        <div class="button-row">
          <button id="btn-toggle-gate" class="mode-button">Gate Mode</button>
        </div>
        <label><input id="visit-all" type="checkbox" checked> Visit fields in listed order</label>
        <button id="btn-confirm-route" class="primary-button">Confirm Plan</button>
        <div id="plan-status"></div>
      </div>
    </section>

    <section id="map-area" class="card" style="padding:0">
      <div id="map-wrapper">
        <canvas id="baseCanvas" width="900" height="900"></canvas>
        <canvas id="overlayCanvas" width="900" height="900"></canvas>
        <canvas id="routeCanvas" width="900" height="900"></canvas>
        <div id="legend">Moisture (orange→blue), pH (red→purple), Nutrients (brown→green)</div>
      </div>
    </section>
  </div>
</main>

<script>
const WORLD_SIZE = 135;
const IMG_URL = "/static/EnvTopView.png";

const base = document.getElementById("baseCanvas");
const over = document.getElementById("overlayCanvas");
const routeCanvas = document.getElementById("routeCanvas");
const bctx = base.getContext("2d");
const octx = over.getContext("2d");
const rctx = routeCanvas.getContext("2d");
const bgImg = new Image();
bgImg.src = IMG_URL;
bgImg.onload = drawAll;

const statusData = {
  name: "—",
  current_state: "IDLE",
  battery: 0,
  emergency: false,
  current_position: {x: 0, y: 0, z: 0},
  target_position: {x: 0, y: 0, z: 0}
};

let soilSamples = [];

const planning = {
  stationName: "",
  robotAddress: "",
  visitAll: true,
  drawingRoute: false,
  drawingField: false,
  gateMode: false,
  routeWidth: 2,
  activeRoutePoints: [],
  activeFieldPoints: [],
  routes: [],
  fields: [],
  nextRouteId: 1,
  nextFieldId: 1,
  activeGateFieldId: null
};

const elements = {
  stationInput: document.getElementById("station-name-input"),
  robotInput: document.getElementById("robot-address-input"),
  routeWidth: document.getElementById("route-width"),
  toggleRoute: document.getElementById("btn-toggle-route"),
  completeRoute: document.getElementById("btn-complete-route"),
  undoPoint: document.getElementById("btn-undo-point"),
  clearRoute: document.getElementById("btn-clear-route"),
  toggleField: document.getElementById("btn-toggle-field"),
  completeField: document.getElementById("btn-complete-field"),
  undoFieldPoint: document.getElementById("btn-undo-field"),
  clearField: document.getElementById("btn-clear-field"),
  toggleGate: document.getElementById("btn-toggle-gate"),
  confirm: document.getElementById("btn-confirm-route"),
  visitAll: document.getElementById("visit-all"),
  planStatus: document.getElementById("plan-status"),
  activeRouteList: document.getElementById("active-route-list"),
  routesList: document.getElementById("routes-list"),
  activeFieldList: document.getElementById("active-field-list"),
  fieldsList: document.getElementById("fields-list")
};

function clamp01(v){return Math.max(0, Math.min(1, v));}
function worldToScreen(x,y){
  const s = base.width / WORLD_SIZE;
  return {x: base.width/2 + x*s, y: base.height/2 - y*s};
}
function screenToWorld(px,py){
  const s = base.width / WORLD_SIZE;
  return {x: (px - base.width/2)/s, y: (base.height/2 - py)/s};
}
function distance2d(a,b){
  const dx=a.x-b.x; const dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy);
}

function polygonCentroid(points){
  if(!points || points.length===0) return null;
  if(points.length===1) return {x: points[0].x, y: points[0].y};
  let area = 0;
  let cx = 0;
  let cy = 0;
  for(let i=0;i<points.length;i++){
    const j = (i+1)%points.length;
    const cross = points[i].x*points[j].y - points[j].x*points[i].y;
    area += cross;
    cx += (points[i].x + points[j].x) * cross;
    cy += (points[i].y + points[j].y) * cross;
  }
  if(Math.abs(area) < 1e-6){
    const sum = points.reduce((acc,pt)=>({x:acc.x+pt.x, y:acc.y+pt.y}), {x:0,y:0});
    return {x: sum.x/points.length, y: sum.y/points.length};
  }
  area *= 0.5;
  const factor = 1/(6*area);
  return {x: cx*factor, y: cy*factor};
}

function pointInPolygon(point, polygon){
  if(!polygon || polygon.length < 3) return false;
  let inside = false;
  for(let i=0,j=polygon.length-1;i<polygon.length;j=i++){
    const xi = polygon[i].x, yi = polygon[i].y;
    const xj = polygon[j].x, yj = polygon[j].y;
    const intersect = ((yi>point.y)!==(yj>point.y)) &&
      (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-9) + xi);
    if(intersect) inside = !inside;
  }
  return inside;
}

function fieldCentroid(outline){
  return polygonCentroid(outline);
}

function findSnapTarget(world){
  let best = null;
  let bestDist = Infinity;

  function consider(candidate, tolerance){
    if(!candidate) return;
    const dist = distance2d(world, candidate);
    if(dist <= tolerance && dist < bestDist){
      best = {x: candidate.x, y: candidate.y};
      bestDist = dist;
    }
  }

  const activeTolerance = Math.max(0.1, planning.routeWidth);
  planning.activeRoutePoints.forEach(pt => consider(pt, activeTolerance));

  const fieldTolerance = Math.max(0.1, planning.routeWidth);
  planning.activeFieldPoints.forEach(pt => consider(pt, fieldTolerance));

  planning.routes.forEach(route => {
    const tolerance = Math.max(0.1, Math.max(route.width, planning.routeWidth));
    route.points.forEach(pt => consider(pt, tolerance));
  });

  planning.fields.forEach(field=>{
    const tolerance = Math.max(0.1, planning.routeWidth);
    field.outline.forEach(pt => consider(pt, tolerance));
  });

  return best;
}

function drawGrid(ctx){
  ctx.lineWidth=1;
  for(let u=Math.ceil(-WORLD_SIZE/2);u<=Math.floor(WORLD_SIZE/2);u++){
    const v = worldToScreen(u,0).x;
    ctx.strokeStyle=(u===0)?"#ef4444":(u%10===0?"#4aa3ff":u%5===0?"#52a2ff55":"#ffffff10");
    ctx.beginPath();ctx.moveTo(v,0);ctx.lineTo(v,base.height);ctx.stroke();
    const h = worldToScreen(0,u).y;
    ctx.strokeStyle=(u===0)?"#ef4444":(u%10===0?"#4aa3ff":u%5===0?"#52a2ff55":"#ffffff10");
    ctx.beginPath();ctx.moveTo(0,h);ctx.lineTo(base.width,h);ctx.stroke();
  }
}
function drawBackground(){
  if(!bgImg.complete)return;
  const iw=bgImg.width, ih=bgImg.height, cw=base.width, ch=base.height;
  const r=Math.max(cw/iw,ch/ih);
  const dw=iw*r, dh=ih*r;
  const dx=(cw-dw)/2, dy=(ch-dh)/2;
  bctx.drawImage(bgImg,dx,dy,dw,dh);
}
function drawDot(ctx,x,y,color,r=6){
  const p=worldToScreen(x,y);
  ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);
  ctx.fillStyle=color;ctx.fill();
  ctx.lineWidth=2;ctx.strokeStyle="rgba(0,0,0,.4)";ctx.stroke();
}
function drawLabel(ctx,text,wx,wy,color="#e8edf4"){
  const p=worldToScreen(wx,wy);
  ctx.save();
  ctx.font="12px system-ui";
  ctx.lineWidth=3;
  ctx.strokeStyle="rgba(0,0,0,.6)";
  ctx.strokeText(text,p.x+8,p.y-6);
  ctx.fillStyle=color;
  ctx.fillText(text,p.x+8,p.y-6);
  ctx.restore();
}

function colormapMoisture(t){
  t=clamp01(t);
  if(t<0.5){const k=t/0.5;return `rgba(${Math.round(255)},${Math.round(140+60*k)},${Math.round(0+80*k)},1)`;}
  const k=(t-0.5)/0.5;
  return `rgba(${Math.round(200-200*k)},${Math.round(220-140*k)},${Math.round(240+15*k)},1)`;
}
function colormapPh(t){
  t=clamp01(t);
  const stops=[[255,0,0],[255,165,0],[255,255,0],[0,200,80],[30,144,255],[128,0,128]];
  const seg=(stops.length-1)*t;
  const i=Math.floor(seg), k=seg-i;
  const a=stops[i], b=stops[Math.min(i+1,stops.length-1)];
  const r=Math.round(a[0]+(b[0]-a[0])*k);
  const g=Math.round(a[1]+(b[1]-a[1])*k);
  const bl=Math.round(a[2]+(b[2]-a[2])*k);
  return `rgba(${r},${g},${bl},1)`;
}
function colormapNutrients(t){
  t=clamp01(t);
  const a=[120,72,28], m=[200,180,60], b=[34,197,94];
  const r=Math.round(a[0]+(m[0]-a[0])*Math.min(t*2,1)+(b[0]-m[0])*Math.max(t*2-1,0));
  const g=Math.round(a[1]+(m[1]-a[1])*Math.min(t*2,1)+(b[1]-m[1])*Math.max(t*2-1,0));
  const bl=Math.round(a[2]+(m[2]-a[2])*Math.min(t*2,1)+(b[2]-m[2])*Math.max(t*2-1,0));
  return `rgba(${r},${g},${bl},1)`;
}

function drawHeatmaps(){
  const showMoist=document.getElementById("chk-moist").checked;
  const showPh=document.getElementById("chk-ph").checked;
  const showNutr=document.getElementById("chk-nutr").checked;
  const radius=+document.getElementById("radius").value;
  const res=+document.getElementById("res").value;
  const alphaPct=+document.getElementById("alpha").value;

  octx.clearRect(0,0,over.width,over.height);
  if(soilSamples.length===0 || (!showMoist && !showPh && !showNutr)) return;

  const off=document.createElement("canvas");
  off.width=res; off.height=res;
  const ox=off.getContext("2d");
  const imgData=ox.createImageData(res,res);
  const data=imgData.data;

  const samples=soilSamples.map(s=>({
    sx:worldToScreen(s.x,s.y).x,
    sy:worldToScreen(s.x,s.y).y,
    moisture:s.moisture,
    ph:s.ph,
    nutrients:s.nutrients
  }));

  const valNorm=(arr,key)=>{
    const vals=arr.map(s=>s[key]).filter(v=>Number.isFinite(v));
    if(!vals.length)return ()=>0;
    const min=Math.min(...vals), max=Math.max(...vals);
    const span=(max-min)||1;
    return v=>(v-min)/span;
  };
  const nMoist=valNorm(samples,"moisture");
  const nPh=v=>clamp01((v-3)/(10.5-3));
  const nNutr=valNorm(samples,"nutrients");

  const power=2;
  const sigma=radius*0.6;
  const inv2s2=sigma>0?1/(2*sigma*sigma):0;

  for(let j=0;j<res;j++){
    for(let i=0;i<res;i++){
      const gx=(i+0.5)*(base.width/res);
      const gy=(j+0.5)*(base.height/res);
      let wsum=0, vm=0, vp=0, vn=0;
      for(const s of samples){
        const dx=gx-s.sx, dy=gy-s.sy;
        const d2=dx*dx+dy*dy;
        const d=Math.sqrt(d2)+1e-6;
        const w=Math.pow(1/d,power)*Math.exp(-d2*inv2s2);
        wsum+=w;
        vm+=w*nMoist(s.moisture);
        vp+=w*nPh(s.ph);
        vn+=w*nNutr(s.nutrients);
      }
      let r=0,g=0,b=0,a=0;
      if(wsum>0){
        const tm=clamp01(vm/wsum);
        const tp=clamp01(vp/wsum);
        const tn=clamp01(vn/wsum);
        const cols=[];
        if(showMoist)cols.push(colormapMoisture(tm));
        if(showPh)cols.push(colormapPh(tp));
        if(showNutr)cols.push(colormapNutrients(tn));
        if(cols.length){
          let R=0,G=0,B=0;
          cols.forEach(c=>{
            const m=c.match(/rgba\((\d+),(\d+),(\d+),1\)/);
            if(!m)return;
            R+=+m[1];G+=+m[2];B+=+m[3];
          });
          R=Math.round(R/cols.length);
          G=Math.round(G/cols.length);
          B=Math.round(B/cols.length);
          r=R;g=G;b=B;a=255;
        }
      }
      const idx=(j*res+i)*4;
      data[idx]=r;data[idx+1]=g;data[idx+2]=b;data[idx+3]=a;
    }
  }

  ox.putImageData(imgData,0,0);
  octx.save();
  octx.globalAlpha=alphaPct/100;
  octx.imageSmoothingEnabled=true;
  octx.drawImage(off,0,0,over.width,over.height);
  octx.restore();
}

function drawPlanning(){
  rctx.clearRect(0,0,routeCanvas.width,routeCanvas.height);
  const scale = base.width / WORLD_SIZE;

  // saved routes
  planning.routes.forEach(route=>{
    if(route.points.length<2) return;
    const widthPx = Math.max(2, route.width * scale * 0.6);
    const pts = route.points.map(pt=>worldToScreen(pt.x,pt.y));
    rctx.save();
    rctx.lineWidth = widthPx;
    rctx.strokeStyle = "#38bdf8";
    rctx.lineCap = "round";
    rctx.lineJoin = "round";
    rctx.beginPath();
    rctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) rctx.lineTo(pts[i].x, pts[i].y);
    rctx.stroke();
    rctx.restore();
  });

  // saved fields
  planning.fields.forEach((field, idx)=>{
    if(field.outline.length<2) return;
    const pts = field.outline.map(pt=>worldToScreen(pt.x, pt.y));
    rctx.save();
    rctx.beginPath();
    rctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) rctx.lineTo(pts[i].x, pts[i].y);
    if(field.outline.length>2){
      rctx.closePath();
    }
    rctx.fillStyle = field.enabled ? "rgba(34,197,94,0.12)" : "rgba(148,163,184,0.10)";
    rctx.strokeStyle = field.enabled ? "#22c55e" : "#64748b";
    rctx.lineWidth = 2;
    if(field.outline.length>2){
      rctx.fill();
    }
    rctx.stroke();
    rctx.restore();

    if(field.gate){
      drawDot(rctx, field.gate.x, field.gate.y, field.enabled ? "#22c55e" : "#64748b", 6);
      drawLabel(rctx, field.label || `Field ${idx+1}`, field.gate.x, field.gate.y-1, field.enabled ? "#22c55e" : "#64748b");
    }else{
      const centroid = fieldCentroid(field.outline);
      if(centroid){
        drawLabel(rctx, (field.label || `Field ${idx+1}`)+" • no gate", centroid.x, centroid.y, "#ea580c");
      }
    }
  });

  // active field outline (dashed)
  if(planning.activeFieldPoints.length>1){
    const pts = planning.activeFieldPoints.map(pt=>worldToScreen(pt.x,pt.y));
    rctx.save();
    rctx.setLineDash([6,6]);
    rctx.strokeStyle = "#22c55e";
    rctx.lineWidth = 2;
    rctx.beginPath();
    rctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) rctx.lineTo(pts[i].x, pts[i].y);
    rctx.stroke();
    rctx.restore();
  }

  // active route (dashed)
  if(planning.activeRoutePoints.length>1){
    const pts = planning.activeRoutePoints.map(pt=>worldToScreen(pt.x,pt.y));
    rctx.save();
    rctx.lineWidth = Math.max(2, planning.routeWidth * scale * 0.5);
    rctx.strokeStyle = "#f97316";
    rctx.setLineDash([8,6]);
    rctx.lineCap="round";
    rctx.beginPath();
    rctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) rctx.lineTo(pts[i].x, pts[i].y);
    rctx.stroke();
    rctx.restore();
  }

  // robot + nav markers
  const cp=statusData.current_position;
  drawDot(rctx,cp.x,cp.y,"#38bdf8",6);
  drawLabel(rctx,"Robot",cp.x,cp.y-1.2,"#38bdf8");
  const tp=statusData.target_position;
  drawDot(rctx,tp.x,tp.y,"#fde047",5);
  drawLabel(rctx,"Nav",tp.x,tp.y-1.2,"#fde047");
}

function drawAll(){
  bctx.clearRect(0,0,base.width,base.height);
  drawBackground();
  drawGrid(bctx);
  drawHeatmaps();
  drawPlanning();
}

function updateStatusUI(){
  document.getElementById("name").textContent=statusData.name ?? "—";
  document.getElementById("state").textContent=statusData.current_state ?? "—";
  const dot=document.querySelector("#state-badge .dot");
  if(dot){
    dot.className=/ERROR|FAULT/i.test(statusData.current_state)?"dot err":(/IDLE/i.test(statusData.current_state)?"dot idle":"dot active");
  }
  const battery=Math.min(Math.max(+statusData.battery||0,0),100);
  document.getElementById("battery-bar").style.width=`${battery}%`;
  document.getElementById("battery-text").textContent=`${battery}%`;
  document.getElementById("emergency").textContent=statusData.emergency?"YES":"No";
  const curr=statusData.current_position;
  const tgt=statusData.target_position;
  const fmt=v=>Number.isFinite(v)?v.toFixed(2):"—";
  document.getElementById("cur-x").textContent=fmt(curr.x);
  document.getElementById("cur-y").textContent=fmt(curr.y);
  document.getElementById("cur-z").textContent=fmt(curr.z);
  document.getElementById("tgt-x").textContent=fmt(tgt.x);
  document.getElementById("tgt-y").textContent=fmt(tgt.y);
  document.getElementById("tgt-z").textContent=fmt(tgt.z);
  document.getElementById("updated").textContent=new Date().toLocaleTimeString();

  if(!planning.stationName && statusData.name){
    planning.stationName = statusData.name;
    elements.stationInput.value = planning.stationName;
  }
  updateActionButtons();
  drawAll();
}

function updatePlanStatus(message,isError=false,isSuccess=false){
  elements.planStatus.textContent = message || "";
  elements.planStatus.classList.remove("error","success");
  if(isError) elements.planStatus.classList.add("error");
  else if(isSuccess) elements.planStatus.classList.add("success");
}

function updateActiveRouteList(){
  const list = elements.activeRouteList;
  list.innerHTML="";
  if(!planning.activeRoutePoints.length){
    const li=document.createElement("li"); li.textContent="—"; list.appendChild(li); return;
  }
  planning.activeRoutePoints.forEach((pt,idx)=>{
    const li=document.createElement("li");
    li.innerHTML = `<span>P${idx+1}</span> (${pt.x.toFixed(2)}, ${pt.y.toFixed(2)})`;
    list.appendChild(li);
  });
}

function updateRoutesList(){
  const list = elements.routesList;
  list.innerHTML="";
  if(!planning.routes.length){
    const li=document.createElement("li"); li.textContent="—"; list.appendChild(li); return;
  }
  planning.routes.forEach(route=>{
    const li=document.createElement("li");
    const labelInput=document.createElement("input");
    labelInput.type="text";
    labelInput.value=route.label;
    labelInput.addEventListener("input",()=>{route.label = labelInput.value.trim() || route.label;});
    const meta=document.createElement("span");
    meta.textContent=`${route.points.length} pts · ${route.width.toFixed(1)}m`;
    const remove=document.createElement("button");
    remove.textContent="Remove";
    remove.addEventListener("click",()=>{removeRoute(route.id);});
    li.appendChild(labelInput);
    li.appendChild(meta);
    li.appendChild(remove);
    list.appendChild(li);
  });
}

function updateActiveFieldList(){
  const list = elements.activeFieldList;
  list.innerHTML="";
  if(!planning.activeFieldPoints.length){
    const li=document.createElement("li"); li.textContent="—"; list.appendChild(li); return;
  }
  planning.activeFieldPoints.forEach((pt,idx)=>{
    const li=document.createElement("li");
    li.innerHTML = `<span>P${idx+1}</span> (${pt.x.toFixed(2)}, ${pt.y.toFixed(2)})`;
    list.appendChild(li);
  });
}

function updateFieldsList(){
  const list = elements.fieldsList;
  list.innerHTML="";
  if(!planning.fields.length){
    const li=document.createElement("li"); li.textContent="—"; list.appendChild(li); return;
  }
  planning.fields.forEach(field=>{
    const li=document.createElement("li");
    const enabled=document.createElement("input");
    enabled.type="checkbox"; enabled.checked=field.enabled;
    enabled.addEventListener("change",()=>{field.enabled = enabled.checked; updatePlanStatus(""); updateActionButtons();});
    const label=document.createElement("input");
    label.type="text"; label.value=field.label;
    label.addEventListener("input",()=>{field.label = label.value.trim() || field.label;});
    const info=document.createElement("span");
    const gateText = field.gate ? `Gate (${field.gate.x.toFixed(2)}, ${field.gate.y.toFixed(2)})` : "Gate pending";
    info.textContent = `${field.outline.length} pts · ${gateText}`;
    const gateBtn=document.createElement("button");
    gateBtn.textContent = planning.activeGateFieldId === field.id && planning.gateMode ? "Click map…" : "Set Gate";
    gateBtn.classList.toggle("active", planning.activeGateFieldId === field.id && planning.gateMode);
    gateBtn.addEventListener("click",()=>{
      planning.activeGateFieldId = field.id;
      if(!planning.gateMode){
        planning.gateMode = true;
        elements.toggleGate.classList.add("active");
        elements.toggleGate.textContent = "Gate Mode (On)";
      }
      updatePlanStatus(`Gate mode: click the map to place gate for ${field.label}.`);
      updateFieldsList();
    });
    const remove=document.createElement("button");
    remove.textContent="Remove";
    remove.addEventListener("click",()=>{removeField(field.id);});
    li.appendChild(enabled);
    li.appendChild(label);
    li.appendChild(info);
    li.appendChild(gateBtn);
    li.appendChild(remove);
    list.appendChild(li);
  });
}

function updateActionButtons(){
  elements.undoPoint.disabled = planning.activeRoutePoints.length===0;
  elements.clearRoute.disabled = planning.activeRoutePoints.length===0;
  elements.completeRoute.disabled = planning.activeRoutePoints.length<2;
  elements.undoFieldPoint.disabled = planning.activeFieldPoints.length===0;
  elements.clearField.disabled = planning.activeFieldPoints.length===0;
  elements.completeField.disabled = planning.activeFieldPoints.length<3;
  const readyFields = planning.fields.filter(f=>f.enabled && f.gate && f.outline.length>=3).length;
  elements.confirm.disabled = !planning.stationName || !planning.robotAddress || planning.routes.length===0 || readyFields===0;
}

function toggleRouteMode(){
  planning.drawingRoute = !planning.drawingRoute;
  if(planning.drawingRoute){
    planning.drawingField = false;
    elements.toggleField.classList.remove("active");
    elements.toggleField.textContent = "Start Field";
    if(planning.gateMode){
      planning.gateMode = false;
      planning.activeGateFieldId = null;
      elements.toggleGate.classList.remove("active");
      elements.toggleGate.textContent = "Gate Mode";
      updateFieldsList();
    }
  }
  elements.toggleRoute.classList.toggle("active", planning.drawingRoute);
  elements.toggleRoute.textContent = planning.drawingRoute ? "Stop Route" : "Start Route";
  if(planning.drawingRoute){
    updatePlanStatus("Route mode: click the map to add path points.");
  } else {
    updatePlanStatus("Route drawing paused.");
  }
}

function toggleFieldMode(){
  planning.drawingField = !planning.drawingField;
  if(planning.drawingField){
    planning.drawingRoute = false;
    elements.toggleRoute.classList.remove("active");
    elements.toggleRoute.textContent = "Start Route";
    if(planning.gateMode){
      planning.gateMode = false;
      planning.activeGateFieldId = null;
      elements.toggleGate.classList.remove("active");
      elements.toggleGate.textContent = "Gate Mode";
      updateFieldsList();
    }
  }
  elements.toggleField.classList.toggle("active", planning.drawingField);
  elements.toggleField.textContent = planning.drawingField ? "Stop Field" : "Start Field";
  if(planning.drawingField){
    updatePlanStatus("Field mode: click the map to trace the field outline.");
  }else{
    updatePlanStatus("Field drawing paused.");
  }
}

function toggleGateMode(){
  if(!planning.fields.length){
    updatePlanStatus("Create a field before placing a gate.", true);
    return;
  }
  planning.gateMode = !planning.gateMode;
  if(!planning.gateMode){
    planning.activeGateFieldId = null;
  }
  elements.toggleGate.classList.toggle("active", planning.gateMode);
  elements.toggleGate.textContent = planning.gateMode ? "Gate Mode (On)" : "Gate Mode";
  if(planning.gateMode){
    updatePlanStatus("Gate mode: click the map to place a gate. Select a field to target.");
  } else {
    updatePlanStatus("Gate placement paused.");
  }
  updateFieldsList();
}

function addRoutePoint(world){
  const snapped = findSnapTarget(world);
  const point = snapped ? snapped : {x: world.x, y: world.y};
  planning.activeRoutePoints.push(point);
  updateActiveRouteList();
  updateActionButtons();
  drawAll();
}

function addFieldPoint(world){
  const snapped = findSnapTarget(world);
  const point = snapped ? snapped : {x: world.x, y: world.y};
  planning.activeFieldPoints.push(point);
  updateActiveFieldList();
  updateActionButtons();
  drawAll();
}

function undoRoutePoint(){
  planning.activeRoutePoints.pop();
  updateActiveRouteList();
  updateActionButtons();
  drawAll();
}

function undoFieldPoint(){
  planning.activeFieldPoints.pop();
  updateActiveFieldList();
  updateActionButtons();
  drawAll();
}

function clearActiveRoute(){
  planning.activeRoutePoints = [];
  updateActiveRouteList();
  updateActionButtons();
  drawAll();
}

function clearActiveField(){
  planning.activeFieldPoints = [];
  updateActiveFieldList();
  updateActionButtons();
  drawAll();
}

function completeRoute(){
  if(planning.activeRoutePoints.length < 2){
    updatePlanStatus("Add at least two points before completing a route.", true);
    return;
  }
  const id = `route-${planning.nextRouteId++}`;
  const label = `Route ${planning.routes.length+1}`;
  planning.routes.push({
    id,
    label,
    width: planning.routeWidth,
    points: planning.activeRoutePoints.slice()
  });
  planning.activeRoutePoints = [];
  planning.drawingRoute = false;
  elements.toggleRoute.classList.remove("active");
  elements.toggleRoute.textContent = "Start Route";
  updateActiveRouteList();
  updateRoutesList();
  updateActionButtons();
  drawAll();
  updatePlanStatus(`Saved ${label}.`, false, true);
}

function completeField(){
  if(planning.activeFieldPoints.length < 3){
    updatePlanStatus("Add at least three points before completing a field.", true);
    return;
  }
  const id = `field-${planning.nextFieldId++}`;
  const label = `Field ${planning.fields.length+1}`;
  planning.fields.push({
    id,
    label,
    enabled: true,
    outline: planning.activeFieldPoints.slice(),
    gate: null
  });
  planning.activeFieldPoints = [];
  planning.drawingField = false;
  elements.toggleField.classList.remove("active");
  elements.toggleField.textContent = "Start Field";
  updateActiveFieldList();
  updateFieldsList();
  updateActionButtons();
  drawAll();
  updatePlanStatus(`Saved ${label}.`, false, true);
}

function removeRoute(id){
  planning.routes = planning.routes.filter(r=>r.id!==id);
  updateRoutesList();
  updateActionButtons();
  drawAll();
}

function removeField(id){
  planning.fields = planning.fields.filter(f=>f.id!==id);
  if(planning.activeGateFieldId === id){
    planning.activeGateFieldId = null;
  }
  updateFieldsList();
  updateActionButtons();
  drawAll();
}

function placeGate(world){
  if(!planning.fields.length){
    updatePlanStatus("Create a field before placing a gate.", true);
    return;
  }
  let target = planning.fields.find(f=>f.id===planning.activeGateFieldId);
  if(!target){
    target = planning.fields.find(field=>pointInPolygon(world, field.outline));
  }
  if(!target){
    let best = null;
    let bestDist = Infinity;
    planning.fields.forEach(field=>{
      const center = fieldCentroid(field.outline);
      if(!center) return;
      const d = distance2d(world, center);
      if(d < bestDist){
        bestDist = d;
        best = field;
      }
    });
    target = best;
  }
  if(!target){
    updatePlanStatus("No field available for gate placement.", true);
    return;
  }
  target.gate = {x: world.x, y: world.y};
  planning.activeGateFieldId = target.id;
  updateFieldsList();
  updateActionButtons();
  drawAll();
  updatePlanStatus(`Gate set for ${target.label}.`, false, true);
}

function confirmPlan(){
  if(elements.confirm.disabled) return;
  const payload = {
    station_name: planning.stationName,
    robot_address: planning.robotAddress,
    visit_all_fields: planning.visitAll,
    start: {
      x: statusData.current_position.x,
      y: statusData.current_position.y,
      z: statusData.current_position.z
    },
    routes: planning.routes.map(route=>({
      label: route.label,
      width: route.width,
      waypoints: route.points.map(pt=>({x:pt.x,y:pt.y,z:0}))
    })),
    fields: planning.fields
      .filter(field=>field.outline.length>=3)
      .map(field=>{
        const gatePoint = field.gate || fieldCentroid(field.outline) || {x:0,y:0};
        return {
          label: field.label,
          enabled: field.enabled,
          gate: {x:gatePoint.x,y:gatePoint.y,z:0},
          outline: field.outline.map(pt=>({x:pt.x,y:pt.y,z:0}))
        };
      })
  };
  updatePlanStatus("Sending plan…");
  elements.confirm.disabled = true;
  fetch("/api/macro-plan",{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify(payload)
  }).then(r=>r.json().then(body=>({ok:r.ok,body}))).then(({ok,body})=>{
    if(ok && body.accepted){
      updatePlanStatus(body.message || "Plan accepted.", false, true);
    }else{
      updatePlanStatus(body.message || "Plan rejected.", true);
    }
  }).catch(err=>{
    updatePlanStatus(`Failed to submit plan: ${err}`, true);
  }).finally(()=>{
    updateActionButtons();
  });
}

function resize(){
  const wrapper=document.getElementById("map-wrapper");
  const w=wrapper.clientWidth || 800;
  base.width=w;base.height=w;
  over.width=w;over.height=w;
  routeCanvas.width=w;routeCanvas.height=w;
  drawAll();
}

elements.stationInput.addEventListener("input",ev=>{
  planning.stationName = ev.target.value.trim();
  updateActionButtons();
});
elements.robotInput.addEventListener("input",ev=>{
  planning.robotAddress = ev.target.value.trim();
  updateActionButtons();
});
elements.routeWidth.addEventListener("input",ev=>{
  planning.routeWidth = parseFloat(ev.target.value) || 2;
  if(planning.drawingRoute) updatePlanStatus(`Active route width set to ${planning.routeWidth.toFixed(1)}m.`);
});
elements.toggleRoute.addEventListener("click",toggleRouteMode);
elements.completeRoute.addEventListener("click",completeRoute);
elements.undoPoint.addEventListener("click",undoRoutePoint);
elements.clearRoute.addEventListener("click",clearActiveRoute);
elements.toggleField.addEventListener("click",toggleFieldMode);
elements.completeField.addEventListener("click",completeField);
elements.undoFieldPoint.addEventListener("click",undoFieldPoint);
elements.clearField.addEventListener("click",clearActiveField);
elements.toggleGate.addEventListener("click",toggleGateMode);
elements.confirm.addEventListener("click",confirmPlan);
elements.visitAll.addEventListener("change",ev=>{
  planning.visitAll = ev.target.checked;
});

routeCanvas.addEventListener("click",evt=>{
  const rect=routeCanvas.getBoundingClientRect();
  const world=screenToWorld(evt.clientX-rect.left, evt.clientY-rect.top);
  if(planning.gateMode){
    placeGate(world);
  }else if(planning.drawingField){
    addFieldPoint(world);
  }else if(planning.drawingRoute){
    addRoutePoint(world);
  }
});
routeCanvas.addEventListener("contextmenu",evt=>evt.preventDefault());

window.addEventListener("resize",resize);
["chk-moist","chk-ph","chk-nutr","radius","res","alpha"].forEach(id=>{
  const el=document.getElementById(id);
  if(el) el.addEventListener("input",drawAll);
});

async function fetchStatus(){
  try{
    const r=await fetch("/api/status",{cache:"no-store"});
    const j=await r.json();
    if(j && !j.error){
      statusData.name=j.name;
      statusData.current_state=j.current_state;
      statusData.battery=Number(j.battery||0);
      statusData.emergency=Boolean(j.emergency);
      statusData.current_position=j.current_position;
      statusData.target_position=j.target_position;
      updateStatusUI();
    }
  }catch(err){console.error("Status fetch failed",err);}
}

async function fetchSoil(){
  try{
    const r=await fetch("/api/soil",{cache:"no-store"});
    const j=await r.json();
    soilSamples=Array.isArray(j?.samples)? j.samples : [];
    drawAll();
  }catch(err){console.error("Soil fetch failed",err);} }

function init(){
  updateActiveRouteList();
  updateRoutesList();
  updateActiveFieldList();
  updateFieldsList();
  updateActionButtons();
  updatePlanStatus("Route mode ready. Start drawing to define paths.");
  resize();
  fetchStatus();
  fetchSoil();
  setInterval(fetchStatus, 1000);
  setInterval(fetchSoil, 1500);
}

init();
</script>
</body>
</html>
